# 理解

## elpis-core

core 在做什么：

- 加入 app 到 app.listen() 之间的控制
- 每个 loader 都会传入 app，所以 app 成了一个方便放数据的地方
- 其他应该都是杂项，需要啥补啥
  - 可能是细碎的，但必要的设计

### extend

提供了一个继续扩展 app 属性或方法的地方。

放在前面是因为这个东西太自由了，因为 loader 全流程都可以传递 app，extend 扩展了 app，想要在其他 loader 中载入时就使用也不是不可能，比如在 controller 的实例化时就用 `app.[扩展方法或属性]` 。

### 主要链条

- app
- router        调用 controller 实例方法，参数可传递包括 `ctx`（固定 ctx 参数）
- controller    调用 service    实例方法，参数（可根据实际业务传递）
- service       这里可以继续扩展一层，但到此为止

实际上，controller 和 service 是可以省略的，不省略是为了重用和利于维护。
为什么只是这两层和叫这两个名字，可能是大家都觉得好用吧。

controller `app/类名/方法` 可以作为路由，因为 router 这里直接调用的就是 controller 的实例方法。

service 作为通用业务的封装。

这样的链条看着像是在初始化 loader 的时候需要按照以下顺序：

service -> controller -> router

要看实例化时是否需要依赖上一级的方法或者属性，但我会保持这样的载入顺序，因为实例化过程是使用者任意控制的，保不齐就想要对 app 的扩展属性进行解构，没有固定顺序可能导致执行结果不一致。

### middlewares

> koa app 中已经有了一个 `middleware`，所以不能重复

其有 middleware 文件夹，又由单独的 `middleware.ts` 拿到每个 middleware 进行再次配置。

这里应该可以省略单独的配置文件而只保留一个文件夹，顺序和配置项可以在各自文件内处理，暂时不明其意义。

### 其他

缺啥补啥

## 工程化

感知认识

- module 提供入口，配置 loader，顺着链条打包
- plugin 连接 module 结果以实现更多可能，如 html
- optimization 这个思路很有收获，如分割逻辑和合理性

和 elpis-core 的联系是 webpack 将前端项目打包为静态，elpis-core 接受请求和渲染页面。

### bugs

> 该 bug 非视频中的，是个人原因造成的

热更新资源不存在的问题：感谢 ai。common 的配置没有在 dev 中被覆盖，导致打包资源固定，不能随意更改。

暂时不修复这个问题，dev 模式下只会在内存中。
